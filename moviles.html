<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JOKESCALE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
</head>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Roboto:wght@400;700&display=swap');
        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #ff6f61, #ffcc00);
            color: white;
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        h1, h2 {
            font-family: 'Playfair Display', serif;
        }
        #startScreen {
            background: rgba(0, 0, 0, 0.5); /* Fondo semi-transparente */
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .card {
            transition: transform 0.2s, scale 0.2s;
            user-select: none;
            background: #ff4444;
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        .card:hover {
            transform: scale(1.1);
        }
        .selected {
            transform: scale(1.3);
            z-index: 10;
            border: 3px solid yellow;
        }
        .dragging {
            opacity: 0.5;
        }
        .red-card {
            color: #ff4444;
        }
        .card-back {

            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Sombra para dar profundidad */
            border: 2px solid gold;
        }
        .card-back::before {
            content: '';
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(255, 255, 255, 0.2) 10px,
                rgba(255, 255, 255, 0.2) 20px
            );
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        .card-back::after {
            content: 'JOKESCALE'; /* Texto o logotipo en el centro */
            font-family: 'Playfair Display', serif;
            font-size: 14px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.5); /* Color semi-transparente */
            transform: rotate(-45deg); /* Rotar el texto para que quede diagonal */
            position: absolute;
        }
        .hidden {
            display: none;
        }

        #deckStyleModal {
            max-width: 600px;
            width: 90%;
        }

        .deck-style-option {
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .deck-style-option:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        #roundCompleteMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 24px;
            z-index: 1000;
            display: none;
        }
        #endRoundCards {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 1000;
            display: none;
            text-align: center;
        }
        #rulesModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 1000;
            display: none;
            text-align: left;
            max-width: 500px;
            width: 90%;
        }
        #gameOverModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 24px;
            z-index: 1000;
            display: none;
            text-align: center;
            max-width: 500px;
            width: 90%;
        }
        #jokerModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            text-align: center;
        }
        #jokerModal select {
            margin: 5px;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #fff;
            color: #000;
        }
        @keyframes slideIn {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        .card-animation {
            animation: slideIn 0.5s ease-out;
        }
    </style>

<body class="bg-gradient-to-r from-red-950 to-red-500">
    <!-- Pantalla de inicio -->
    <div id="startScreen">
        <h1 class="text-6xl font-bold mb-8">JOKESCALE</h1>
        <button id="startGame" class="mt-4 px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Iniciar Juego</button>
        <button id="showRules" class="mt-4 px-6 py-2 bg-purple-600 text-white rounded hover:bg-purple-700">Reglas</button>
        <button id="changeBackground" class="mt-4 px-6 py-2 bg-green-600 text-white rounded hover:bg-green-700">Cambiar Fondo</button>
        <button id="showStats" class="mt-4 px-6 py-2 bg-gray-600 text-white rounded hover:bg-gray-700">Ver Estad√≠sticas</button>
        <button id="changeDeckStyle" class="mt-4 px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Cambiar Estilo de Baraja</button>
        <div id="statsModal" class="hidden fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-90 text-white p-6 rounded-lg shadow-lg text-center">
            <h2 class="text-2xl font-bold mb-4">Estad√≠sticas</h2>
            <p id="statsContent"></p>
            <button id="closeStats" class="mt-4 px-6 py-2 bg-red-600 text-white rounded hover:bg-red-700">Cerrar</button>
        </div>
        <!-- Ventana modal para seleccionar el estilo de baraja -->
        <div id="deckStyleModal" class="hidden fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-90 text-white p-6 rounded-lg shadow-lg text-center">
            <h2 class="text-2xl font-bold mb-4">Selecciona un estilo de baraja</h2>
            <div class="flex gap-4 justify-center">
                <div class="deck-style-option bg-white p-4 rounded-lg cursor-pointer" data-style="default">
                    <img src="images/images/default-deck.png" alt="Estilo Predeterminado" class="w-24 h-32">
                    <p class="mt-2 text-black">Predeterminado</p>
                </div>
                <div class="deck-style-option bg-white p-4 rounded-lg cursor-pointer" data-style="classic">
                    <img src="images/images/classic-deck.png" alt="Estilo Cl√°sico" class="w-24 h-32">
                    <p class="mt-2 text-black">Cl√°sico</p>
                </div>
                <div class="deck-style-option bg-white p-4 rounded-lg cursor-pointer" data-style="modern">
                    <img src="images/images/modern-deck.png" alt="Estilo Moderno" class="w-24 h-32">
                    <p class="mt-2 text-black">Moderno</p>
                </div>
            </div>
            <button id="closeDeckStyleModal" class="mt-4 px-6 py-2 bg-red-600 text-white rounded hover:bg-red-700">Cerrar</button>
        </div>

        <div class="mt-4">
            <label for="difficulty" class="text-xl">Dificultad:</label>
            <select id="difficulty" class="ml-2 px-2 py-1 bg-white text-black rounded">
                <option value="easy">F√°cil</option>
                <option value="medium">Medio</option>
                <option value="hard">Dif√≠cil</option>
            </select>

        </div>
    </div>

    <!-- √Årea del juego (oculta inicialmente) -->
    <div id="gameArea" class="hidden">
        <div class="container mx-auto px-4 py-8">
            <h1 class="text-4xl sm:text-5xl md:text-6xl font-bold text-center mb-8">JOKESCALE</h1>
            <div class="flex flex-col sm:flex-row gap-4">
                <div id="playerArea" class="w-full sm:w-1/2">
                    <h2 class="text-2xl font-semibold">Tus Cartas</h2>
                    <div id="playerCards" class="flex flex-wrap justify-center"></div>
                </div>
                <div id="opponentArea" class="w-full sm:w-1/2">
                    <h2 class="text-2xl font-semibold">Oponente</h2>
                    <div id="opponentCards" class="flex flex-wrap justify-center"></div>
                </div>
            </div>
        </div>
    </div>
                <div id="totalTimer" class="text-xl mt-4">Tiempo total: 0s</div>

                <div id="discardPile" class="w-24 h-32 bg-gray-800 flex items-center justify-center my-4 rounded-lg"
                     ondragover="allowDrop(event)"
                     ondrop="dropOnDiscard(event)">
                    <span class="text-lg">Descarte</span>
                </div>
                <div id="playerArea" class="w-full mt-4">
                    <h2 class="text-2xl font-semibold">Tus Cartas</h2>
                    <div id="playerCards" class="flex flex-wrap justify-center"></div>
                </div>
                <div class="flex gap-4">
                    <button id="drawCard" class="mt-4 px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Robar de la Baraja</button>
                    <button id="drawDiscard" class="mt-4 px-6 py-2 bg-purple-600 text-white rounded hover:bg-purple-700">Robar del Descarte</button>
                </div>
                <div id="roundInfo" class="mt-4 text-xl"></div>
                <div id="scoreInfo" class="mt-4 text-xl"></div>
                <div id="message" class="mt-4 text-xl text-yellow-400"></div>
            </div>
        </div>
    </div>

    <!-- Mensaje de ronda completada -->
    <div id="roundCompleteMessage">¬°Has pasado a la siguiente ronda!</div>

    <!-- Cartas al final de la ronda -->
    <div id="endRoundCards">
        <h3 class="text-2xl font-semibold mb-4">Cartas no combinadas</h3>
        <div id="playerEndCards" class="mb-4"></div>
        <div id="opponentEndCards" class="mb-4"></div>
        <div id="endRoundScore" class="text-xl"></div>
    </div>

    <!-- Modal de reglas -->
    <div id="rulesModal">
        <h2 class="text-2xl font-bold mb-4">Reglas del Juego</h2>
        <p class="mb-2">1. El objetivo es formar combinaciones de cartas (tr√≠os o escaleras) en cada ronda.</p>
        <p class="mb-2">2. Las cartas J, Q y K valen 10 puntos. El As vale 1 punto. Las dem√°s cartas valen su valor num√©rico.</p>
        <p class="mb-2">3. Los Jokers pueden reemplazar cualquier carta para completar combinaciones.</p>
        <p class="mb-2">4. Al final de cada ronda, las cartas no combinadas suman puntos. El jugador con menos puntos gana.</p>
        <button id="closeRules" class="mt-4 px-6 py-2 bg-red-600 text-white rounded hover:bg-red-700">Cerrar</button>
    </div>

    <!-- Ventana modal de fin de juego -->
    <div id="gameOverModal">
        <h2 id="gameOverMessage" class="text-3xl font-bold mb-4"></h2>
        <p id="finalScore" class="text-xl mb-4"></p>
        <button id="restartGame" class="mt-4 px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Volver al inicio</button>
    </div>

    <!-- Modal para seleccionar el valor y palo del Joker -->
    <div id="jokerModal">
        <h2 class="text-xl font-bold mb-4">Selecciona el valor y el palo del Joker</h2>
        <select id="jokerValue" class="p-2 border rounded mb-4">
            <option value="A">A</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
            <option value="J">J</option>
            <option value="Q">Q</option>
            <option value="K">K</option>
        </select>
        <select id="jokerSuit" class="p-2 border rounded mb-4">
            <option value="‚ô•">‚ô•</option>
            <option value="‚ô¶">‚ô¶</option>
            <option value="‚ô£">‚ô£</option>
            <option value="‚ô†">‚ô†</option>
        </select>
        <div class="flex gap-4">
            <button id="confirmJoker" class="mt-4 px-4 py-2 bg-blue-600 text-white rounded">Confirmar</button>
            <button id="cancelJoker" class="mt-4 px-4 py-2 bg-red-600 text-white rounded">Cancelar</button>
        </div>
    </div>

    <script>
        const suits = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
        const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        let deck = [];
        let playerHand = [];
        let opponentHand = [];
        let discardPile = [];
        let currentRound = 1;
        let playerScore = 0;
        let opponentScore = 0;
        let hasDrawnCard = false;
        let selectedCardIndex = null;
        let difficulty = 'easy';
        let stats = {
            gamesPlayed: 0,
            gamesWon: 0,
            totalTime: 0, // Tiempo total en segundos
            bestTime: null, // Mejor tiempo (inicialmente null
        };

        const roundRequirements = [
            { type: 'trio', count: 1, cardsNeeded: 3 },
            { type: 'escalera', count: 1, cardsNeeded: 4 },
            { type: 'trio', count: 2, cardsNeeded: 6 },
            { type: 'mixed', count: 1, cardsNeeded: 7 }, // 1 tr√≠o y 1 escalera
            { type: 'escalera', count: 2, cardsNeeded: 8 }
        ];

        const backgrounds = [
            'bg-gradient-to-r from-red-500 to-yellow-400',
            'bg-gradient-to-r from-green-500 to-teal-400',
            'bg-gradient-to-r from-purple-500 to-pink-400',
            'bg-gradient-to-r from-blue-800 to-teal-500', // Fondo Azul
            'bg-gradient-to-r from-red-950 to-red-500' //Fondo sangriento
        ];
        let currentBackground = 0;

        // Funci√≥n para cambiar el fondo
        function changeBackground() {
            currentBackground = (currentBackground + 1) % backgrounds.length;
            document.body.className = backgrounds[currentBackground];
        }

        // Funci√≥n para mostrar las reglas
        function showRules() {
            document.getElementById('rulesModal').style.display = 'block';
        }

        // Funci√≥n para ocultar las reglas
        function hideRules() {
            document.getElementById('rulesModal').style.display = 'none';
        }

        // Funci√≥n para iniciar el juego
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameArea').classList.remove('hidden');
            createDeck();
            dealCards();
            resetTotalTimer(); // Reiniciar el contador
            startTotalTimer(); // Iniciar el contador
        }

        // Funci√≥n para crear el mazo
        function createDeck() {
            deck = [];
            for (let suit of suits) {
                for (let value of values) {
                    deck.push({ suit, value });
                }
            }
            deck.push({ suit: 'üÉè', value: 'Joker' });
            deck.push({ suit: 'üÉè', value: 'Joker' });
            shuffleDeck();
        }

        // Funci√≥n para barajar el mazo
        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        // Funci√≥n para repartir cartas
        function dealCards() {
            const cardsNeeded = roundRequirements[currentRound - 1].cardsNeeded;
            playerHand = deck.splice(0, cardsNeeded);
            opponentHand = deck.splice(0, cardsNeeded);
            updateGameArea();

            // A√±adir la clase de animaci√≥n a las cartas del jugador y del oponente
            const playerCards = document.querySelectorAll('#playerCards .card');
            const opponentCards = document.querySelectorAll('#opponentCards .card');

            playerCards.forEach(card => card.classList.add('card-animation'));
            opponentCards.forEach(card => card.classList.add('card-animation'));

            // Eliminar la clase despu√©s de que termine la animaci√≥n
            setTimeout(() => {
                playerCards.forEach(card => card.classList.remove('card-animation'));
                opponentCards.forEach(card => card.classList.remove('card-animation'));
            }, 500); // 500ms es la duraci√≥n de la animaci√≥n
        }

        // Funci√≥n para actualizar el √°rea de juego
        function updateGameArea() {
            // Cartas del oponente (boca abajo)
            document.getElementById('opponentCards').innerHTML = opponentHand.map(() => `
                <div class="card ${deckStyles[currentDeckStyle].back} text-black w-16 h-24 m-2 flex items-center justify-center rounded-lg shadow-lg">
                    <div class="card-back"></div>
                </div>
            `).join('');

            // Cartas del jugador (boca arriba)
            document.getElementById('playerCards').innerHTML = playerHand.map((card, index) => `
                <div class="card ${deckStyles[currentDeckStyle].front} text-black w-16 h-24 m-2 flex items-center justify-center rounded-lg shadow-lg cursor-pointer ${selectedCardIndex === index ? 'selected' : ''}"
                     draggable="true"
                     ondragstart="dragCard(event, ${index})"
                     ondragover="allowDrop(event)"
                     ondrop="dropCard(event, ${index})"
                     onclick="selectCard(${index})">
                    <span class="${card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'red-card' : ''}">${card.value}${card.suit}</span>
                </div>
            `).join('');

            // Descarte
            document.getElementById('discardPile').innerHTML = discardPile.length > 0 ? `
                <div class="card ${deckStyles[currentDeckStyle].front} text-black w-16 h-24 flex items-center justify-center rounded-lg shadow-lg">
                    <span class="${discardPile[discardPile.length - 1].suit === '‚ô•' || discardPile[discardPile.length - 1].suit === '‚ô¶' ? 'red-card' : ''}">
                        ${discardPile[discardPile.length - 1].value}${discardPile[discardPile.length - 1].suit}
                    </span>
                </div>
            ` : '<span class="text-lg">Descarte</span>';

            // Informaci√≥n de la ronda y puntuaci√≥n
            document.getElementById('roundInfo').innerText = `Ronda ${currentRound}: ${roundRequirements[currentRound - 1].type}`;
            document.getElementById('scoreInfo').innerText = `Puntuaci√≥n: T√∫ ${playerScore} - Oponente ${opponentScore}`;
        }

        // Funci√≥n para seleccionar una carta
        function selectCard(index) {
            if (playerHand[index].value === 'Joker') {
                document.getElementById('jokerModal').style.display = 'block';
                selectedCardIndex = index;
            } else {
                selectedCardIndex = index;
            }
            updateGameArea();
        }

        // Funci√≥n para arrastrar una carta
        function dragCard(event, index) {
            event.dataTransfer.setData('text/plain', index);
            event.target.classList.add('dragging');
        }

        // Funci√≥n para permitir soltar una carta
        function allowDrop(event) {
            event.preventDefault();
        }

        // Funci√≥n para soltar una carta en una nueva posici√≥n
        function dropCard(event, targetIndex) {
            event.preventDefault();
            const sourceIndex = event.dataTransfer.getData('text/plain');
            const draggedCard = playerHand[sourceIndex];
            playerHand.splice(sourceIndex, 1);
            playerHand.splice(targetIndex, 0, draggedCard);
            updateGameArea();
        }

        // Funci√≥n para descartar una carta
        function dropOnDiscard(event) {
            event.preventDefault();
            if (!hasDrawnCard) {
                showMessage('Debes robar una carta antes de descartar.');
                return;
            }

            if (selectedCardIndex !== null) {
                discardPile.push(playerHand.splice(selectedCardIndex, 1)[0]);
                selectedCardIndex = null;
                hasDrawnCard = false; // Reiniciar el control de robo de carta
                updateGameArea();

                if (checkCombinations(playerHand)) {
                    endRound();
                } else {
                    opponentTurn();
                }
            }
        }

        // Funci√≥n para el turno del oponente
        function opponentTurn() {
            setTimeout(() => {
                if (deck.length > 0 && !checkCombinations(opponentHand)) {
                    opponentHand.push(deck.pop());
                    updateGameArea();
                }

                if (opponentHand.length > 0) {
                    const cardToDiscard = opponentHand.pop();
                    discardPile.push(cardToDiscard);
                    updateGameArea();
                }

                if (checkCombinations(opponentHand)) {
                    endRound();
                }
            }, 1000);
        }

        // Funci√≥n para verificar combinaciones
       function checkCombinations(hand) {
            const required = roundRequirements[currentRound - 1];

            // Verificar si se cumplen las combinaciones requeridas
            let combinationsMet = false;
            if (required.type === 'trio') {
                combinationsMet = checkTrios(hand, required.count);
            } else if (required.type === 'escalera') {
                combinationsMet = checkEscaleras(hand, required.count);
            } else if (required.type === 'mixed') {
                combinationsMet = checkMixed(hand, required.count);
            }

            // Verificar la nueva condici√≥n: m√°ximo una carta no combinada
            const nonCombinedCards = getNonCombinedCards(hand);
            const canPassRound = nonCombinedCards.length <= 1;

            // Solo se puede pasar de ronda si se cumplen ambas condiciones
            return combinationsMet && canPassRound;
        }

        // Esta funci√≥n identificar√° las cartas que no forman parte de ninguna combinaci√≥n v√°lida
        function getNonCombinedCards(hand) {
            const combinations = getCombinations(hand); // Obtener todas las combinaciones v√°lidas
            const nonCombined = hand.filter(card => {
                // Verificar si la carta no est√° en ninguna combinaci√≥n
                return !combinations.some(combination => combination.includes(card));
            });
            return nonCombined;
        }

        // Funci√≥n para verificar tr√≠os
        function checkTrios(hand, count) {
            const valueCounts = {};
            const jokers = hand.filter(card => card.value === 'Joker').length; // Contar Jokers

            hand.forEach(card => {
                if (card.value !== 'Joker') {
                    valueCounts[card.value] = (valueCounts[card.value] || 0) + 1;
                }
            });

            let trios = 0;
            for (const value in valueCounts) {
                const total = valueCounts[value] + jokers;
                trios += Math.floor(total / 3);
            }

            return trios >= count;
        }

        // Funci√≥n para verificar escaleras
        function checkEscaleras(hand, count) {
            const suitGroups = {};
            hand.forEach(card => {
                if (card.suit !== 'Joker') {
                    if (!suitGroups[card.suit]) suitGroups[card.suit] = [];
                    suitGroups[card.suit].push(card);
                }
            });

            let escaleras = 0;
            for (const suit in suitGroups) {
                const sortedCards = suitGroups[suit].sort((a, b) => values.indexOf(a.value) - values.indexOf(b.value));
                let sequenceLength = 1;
                for (let i = 1; i < sortedCards.length; i++) {
                    const prevValue = values.indexOf(sortedCards[i - 1].value);
                    const currentValue = values.indexOf(sortedCards[i].value);
                    if (currentValue === prevValue + 1) {
                        sequenceLength++;
                        if (sequenceLength >= 3) {
                            escaleras++;
                            sequenceLength = 1;
                        }
                    } else {
                        sequenceLength = 1;
                    }
                }

                // Verificar escalera especial: J, Q, K, A, 2
                const specialSequence = ['J', 'Q', 'K', 'A', '2'];
                const hasSpecialSequence = specialSequence.every(value =>
                    sortedCards.some(card => card.value === value)
                );
                if (hasSpecialSequence) {
                    escaleras++;
                }
            }

            return escaleras >= count;
        }

        // Funci√≥n para verificar combinaciones mixtas
        function checkMixed(hand, count) {
            const triosCount = countTrios(hand); // Contar tr√≠os
            const escalerasCount = countEscaleras(hand); // Contar escaleras

            // Verificar si se cumplen los requisitos de la ronda
            return triosCount >= count && escalerasCount >= count;
        }

        // Funciones para Contar Tr√≠os y Escaleras

        function countTrios(hand) {
            const valueCounts = {};
            const jokers = hand.filter(card => card.value === 'Joker').length; // Contar Jokers

            hand.forEach(card => {
                if (card.value !== 'Joker') {
                    valueCounts[card.value] = (valueCounts[card.value] || 0) + 1;
                }
            });

            let trios = 0;
            for (const value in valueCounts) {
                const total = valueCounts[value] + jokers;
                trios += Math.floor(total / 3);
            }

            return trios;
        }

        function countEscaleras(hand) {
            const suitGroups = {};
            hand.forEach(card => {
                if (card.suit !== 'Joker') {
                    if (!suitGroups[card.suit]) suitGroups[card.suit] = [];
                    suitGroups[card.suit].push(card);
                }
            });

            let escaleras = 0;
            for (const suit in suitGroups) {
                const sortedCards = suitGroups[suit].sort((a, b) => values.indexOf(a.value) - values.indexOf(b.value));
                let sequenceLength = 1;
                for (let i = 1; i < sortedCards.length; i++) {
                    const prevValue = values.indexOf(sortedCards[i - 1].value);
                    const currentValue = values.indexOf(sortedCards[i].value);
                    if (currentValue === prevValue + 1) {
                        sequenceLength++;
                        if (sequenceLength >= 3) {
                            escaleras++;
                            sequenceLength = 1;
                        }
                    } else {
                        sequenceLength = 1;
                    }
                }

                // Verificar escalera especial: J, Q, K, A, 2
                const specialSequence = ['J', 'Q', 'K', 'A', '2'];
                const hasSpecialSequence = specialSequence.every(value =>
                    sortedCards.some(card => card.value === value)
                );
                if (hasSpecialSequence) {
                    escaleras++;
                }
            }

            return escaleras;
        }

        // Funci√≥n para finalizar la ronda
        function endRound() {
            const playerNonCombined = getNonCombinedCards(playerHand);
            const opponentNonCombined = getNonCombinedCards(opponentHand);

            // Verificar si el jugador puede pasar de ronda
            if (playerNonCombined.length > 1) {
                showMessage('No puedes pasar de ronda: tienes m√°s de una carta no combinada.');
                return;
            }

            // Mostrar las cartas no combinadas
            showEndRoundCards();

            // Calcular puntos
            const playerPoints = calculatePoints(playerHand);
            const opponentPoints = calculatePoints(opponentHand);
            playerScore += playerPoints;
            opponentScore += opponentPoints;
            document.getElementById('endRoundScore').innerText = `Puntos en esta ronda: T√∫ ${playerPoints} - Oponente ${opponentPoints}`;

            // Pasar a la siguiente ronda despu√©s de un tiempo
            setTimeout(() => {
                document.getElementById('endRoundCards').style.display = 'none';
                nextRound();
            }, 5000);
        }
        // Funci√≥n para calcular puntos
        function calculatePoints(hand) {
            let points = 0;

            // Verificar si las cartas est√°n en combinaciones v√°lidas
            const isCardInCombination = (card, combinations) => {
                return combinations.some(combination => combination.includes(card));
            };

            // Obtener combinaciones v√°lidas (tr√≠os o escaleras)
            const combinations = getCombinations(hand);

            // Calcular puntos solo para cartas no combinadas
            hand.forEach(card => {
                if (!isCardInCombination(card, combinations)) {
                    if (card.value === 'J' || card.value === 'Q' || card.value === 'K') {
                        points += 10;
                    } else if (card.value === 'A') {
                        points += 1;
                    } else if (card.value === 'Joker') {
                        points += 0;
                    } else {
                        points += parseInt(card.value);
                    }
                }
            });

            return points;
        }

        // Funci√≥n para obtener combinaciones v√°lidas (tr√≠os o escaleras)
        function getCombinations(hand) {
            const combinations = [];

            // Verificar tr√≠os
            const valueCounts = {};
            hand.forEach(card => {
                if (card.value !== 'Joker') {
                    valueCounts[card.value] = (valueCounts[card.value] || 0) + 1;
                }
            });
            for (const value in valueCounts) {
                if (valueCounts[value] >= 3) {
                    combinations.push(hand.filter(card => card.value === value));
                }
            }

            // Verificar escaleras
            const suitGroups = {};
            hand.forEach(card => {
                if (card.suit !== 'Joker') {
                    if (!suitGroups[card.suit]) suitGroups[card.suit] = [];
                    suitGroups[card.suit].push(card);
                }
            });
            for (const suit in suitGroups) {
                const sortedCards = suitGroups[suit].sort((a, b) => values.indexOf(a.value) - values.indexOf(b.value));
                for (let i = 0; i < sortedCards.length - 2; i++) {
                    const sequence = [sortedCards[i], sortedCards[i + 1], sortedCards[i + 2]];
                    const sequenceValues = sequence.map(card => values.indexOf(card.value));
                    if (sequenceValues[2] - sequenceValues[0] === 2) {
                        combinations.push(sequence);
                    }
                }
            }

            return combinations;
        }

        // Funci√≥n para mostrar las cartas al final de la ronda
        function showEndRoundCards() {
            document.getElementById('playerEndCards').innerHTML = `
                <h4 class="text-xl font-semibold mb-2">Tus cartas no combinadas:</h4>
                <div class="flex flex-wrap justify-center">
                    ${playerHand.map(card => `
                        <div class="card bg-white text-black w-16 h-24 m-2 flex items-center justify-center rounded-lg shadow-lg">
                            <span class="${card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'red-card' : ''}">${card.value}${card.suit}</span>
                        </div>
                    `).join('')}
                </div>
            `;

            document.getElementById('opponentEndCards').innerHTML = `
                <h4 class="text-xl font-semibold mb-2">Cartas no combinadas del oponente:</h4>
                <div class="flex flex-wrap justify-center">
                    ${opponentHand.map(card => `
                        <div class="card bg-white text-black w-16 h-24 m-2 flex items-center justify-center rounded-lg shadow-lg">
                            <span class="${card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'red-card' : ''}">${card.value}${card.suit}</span>
                        </div>
                    `).join('')}
                </div>
            `;

            document.getElementById('endRoundCards').style.display = 'block';
        }

        // Funci√≥n para avanzar a la siguiente ronda
        function nextRound() {
            currentRound++;
            if (currentRound <= roundRequirements.length) {
                createDeck();
                dealCards();
            } else {
                endGame();
            }
        }

        // Funci√≥n para finalizar el juego
        function endGame() {
            stopTotalTimer(); // Detener el contador de tiempo total
            stats.gamesPlayed++; // Incrementar partidas jugadas
            stats.totalTime += totalTime; // Sumar el tiempo de esta partida al tiempo total

            // Verificar si el tiempo actual es el mejor
            if (stats.bestTime === null || totalTime < stats.bestTime) {
                stats.bestTime = totalTime; // Actualizar el mejor tiempo
            }

            saveStats(); // Guardar las estad√≠sticas

            const gameOverModal = document.getElementById('gameOverModal');
            const gameOverMessage = document.getElementById('gameOverMessage');
            const finalScore = document.getElementById('finalScore');

            if (playerScore < opponentScore) {
                gameOverMessage.innerText = '¬°Victoria! Has ganado el juego.';
                gameOverMessage.style.color = 'green';
                stats.gamesWon++; // Incrementar partidas ganadas
            } else if (playerScore > opponentScore) {
                gameOverMessage.innerText = 'Derrota. El oponente ha ganado el juego.';
                gameOverMessage.style.color = 'red';
            } else {
                gameOverMessage.innerText = 'El juego ha terminado en empate.';
                gameOverMessage.style.color = 'yellow';
            }

            finalScore.innerText = `Puntuaci√≥n final: T√∫ ${playerScore} - Oponente ${opponentScore}\nTiempo total: ${formatTime(totalTime)}`;
            gameOverModal.style.display = 'block';
        }

        // Funci√≥n para reiniciar el juego
        function restartGame() {
            const gameOverModal = document.getElementById('gameOverModal');
            gameOverModal.style.display = 'none'; // Ocultar la ventana modal

            // Reiniciar variables del juego
            currentRound = 1;
            playerScore = 0;
            opponentScore = 0;
            playerHand = [];
            opponentHand = [];
            discardPile = [];
            hasDrawnCard = false;
            selectedCardIndex = null;

            // Reiniciar el contador de tiempo total
            resetTotalTimer();

            // Volver a la pantalla de inicio
            document.getElementById('gameArea').classList.add('hidden');
            document.getElementById('startScreen').style.display = 'block';
        }

        // Event listeners
        document.getElementById('startGame').addEventListener('click', startGame);
        document.getElementById('showRules').addEventListener('click', showRules);
        document.getElementById('closeRules').addEventListener('click', hideRules);
        document.getElementById('changeBackground').addEventListener('click', changeBackground);
        document.getElementById('restartGame').addEventListener('click', restartGame);
        document.getElementById('drawCard').addEventListener('click', () => {
            if (deck.length === 0) {
                // Si la baraja principal est√° vac√≠a, revolver el descarte (excepto la √∫ltima carta)
                if (discardPile.length > 1) {
                    deck = discardPile.slice(0, -1); // Tomar todas las cartas excepto la √∫ltima
                    discardPile = [discardPile[discardPile.length - 1]]; // Dejar solo la √∫ltima carta en el descarte
                    shuffleDeck();
                } else {
                    showMessage('No hay m√°s cartas para robar.');
                    return;
                }
            }

            if (!hasDrawnCard) {
                playerHand.push(deck.pop());
                hasDrawnCard = true;
                updateGameArea();
            } else {
                showMessage('Ya robaste una carta este turno.');
            }
        });

        document.getElementById('drawDiscard').addEventListener('click', () => {
            if (discardPile.length > 0 && !hasDrawnCard) {
                playerHand.push(discardPile.pop());
                hasDrawnCard = true;
                updateGameArea();
            } else if (hasDrawnCard) {
                showMessage('Ya robaste una carta este turno.');
            } else {
                showMessage('No hay cartas en el descarte.');
            }
        });

        // Event listener para confirmar el valor y palo del Joker
        document.getElementById('confirmJoker').addEventListener('click', () => {
            const selectedValue = document.getElementById('jokerValue').value;
            const selectedSuit = document.getElementById('jokerSuit').value;

            // Convertir el Joker en la carta seleccionada
            playerHand[selectedCardIndex].value = selectedValue;
            playerHand[selectedCardIndex].suit = selectedSuit;

            // Ocultar el modal y actualizar el √°rea de juego
            document.getElementById('jokerModal').style.display = 'none';
            updateGameArea();
        });

        // Event listener para cancelar la conversi√≥n del Joker
        document.getElementById('cancelJoker').addEventListener('click', () => {
            document.getElementById('jokerModal').style.display = 'none'; // Cerrar el modal
            selectedCardIndex = null; // Reiniciar la selecci√≥n
        });

        let totalTimer;
        let totalTime = 0; // Tiempo total en segundos

        // Funci√≥n para iniciar el contador de tiempo total
        function startTotalTimer() {
            totalTimer = setInterval(() => {
                totalTime++;
                document.getElementById('totalTimer').innerText = `Tiempo total: ${formatTime(totalTime)}`;
            }, 1000);
        }


        // Funci√≥n para detener el contador de tiempo total
        function stopTotalTimer() {
            clearInterval(totalTimer);
        }

        // Funci√≥n para reiniciar el contador de tiempo total
        function resetTotalTimer() {
            clearInterval(totalTimer);
            totalTime = 0;
            document.getElementById('totalTimer').innerText = `Tiempo total: ${totalTime}s`;
        }
        function saveStats() {
            localStorage.setItem('JokescaleStats', JSON.stringify(stats));
        }

        function loadStats() {
            const savedStats = localStorage.getItem('JokescaleStats');
            if (savedStats) {
                stats = JSON.parse(savedStats);
            }
        }
        document.getElementById('showStats').addEventListener('click', () => {
            loadStats(); // Cargar las estad√≠sticas
            const statsContent = `
                Partidas jugadas: ${stats.gamesPlayed}<br>
                Partidas ganadas: ${stats.gamesWon}<br>
                Mejor tiempo: ${stats.bestTime !== null ? formatTime(stats.bestTime) : "N/A"}<br>
                Tiempo total: ${formatTime(stats.totalTime)}<
            `;
            document.getElementById('statsContent').innerHTML = statsContent;
            document.getElementById('statsModal').classList.remove('hidden'); // Mostrar la ventana modal

        });
        document.getElementById('closeStats').addEventListener('click', () => {
            document.getElementById('statsModal').classList.add('hidden'); // Ocultar la ventana modal
        });
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600); // Calcular horas
            const minutes = Math.floor((seconds % 3600) / 60); // Calcular minutos
            const secs = seconds % 60; // Calcular segundos

            // Asegurarse de que siempre haya dos d√≠gitos
            const pad = (num) => num < 10 ? `0${num}` : num;

            return `${pad(hours)}:${pad(minutes)}:${pad(secs)}`;
        }

        function showMessage(message) {
            const messageElement = document.getElementById('message');
            messageElement.innerText = message;
            setTimeout(() => {
                messageElement.innerText = ''; // Limpiar el mensaje despu√©s de unos segundos
            }, 3000);
        }

        if (stats.bestTime === totalTime) {
            showMessage('¬°Nuevo r√©cord! Has completado el juego en tu mejor tiempo.');
        }
        const deckStyles = {
            default: {
                back: 'bg-red-500', // Fondo rojo para cartas boca abajo
                front: 'bg-white',  // Fondo blanco para cartas boca arriba
            },
            classic: {
                back: 'bg-blue-500', // Fondo azul para cartas boca abajo
                front: 'bg-gray-300', // Fondo gris claro para cartas boca arriba
            },
            modern: {
                back: 'bg-gray-800', // Fondo negro para cartas boca abajo
                front: 'bg-yellow-100', // Fondo amarillo claro para cartas boca arriba
            },
        };

        let currentDeckStyle = 'default'; // Estilo actual de la baraja

        function changeDeckStyle(style) {
            currentDeckStyle = style;
            updateGameArea(); // Actualizar el √°rea de juego para reflejar el nuevo estilo
        }

        // Abrir la ventana modal
        document.getElementById('changeDeckStyle').addEventListener('click', () => {
            document.getElementById('deckStyleModal').classList.remove('hidden');
        });

        // Cerrar la ventana modal
        document.getElementById('closeDeckStyleModal').addEventListener('click', () => {
            document.getElementById('deckStyleModal').classList.add('hidden');
        });

        // Cambiar el estilo de la baraja
        document.querySelectorAll('.deck-style-option').forEach(option => {
            option.addEventListener('click', () => {
                const style = option.getAttribute('data-style');
                changeDeckStyle(style);
                document.getElementById('deckStyleModal').classList.add('hidden');
            });
        });

    </script>
</body>
</html>